package com.github.yeriomin.playstoreapi;

import org.apache.http.conn.params.ConnManagerParams;
import org.apache.http.conn.params.ConnPerRouteBean;
import org.apache.http.entity.ByteArrayEntity;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpParams;

import java.io.IOException;
import java.math.BigInteger;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.StringTokenizer;

/**
 * This class provides
 * <code>checkin, search, details, bulkDetails, browse, list and download</code>
 * capabilities. It uses <code>Apache Commons HttpClient</code> for POST and GET
 * requests.
 * <p>
 * <p>
 * <b>XXX : DO NOT call checkin, login and download consecutively. To allow
 * server to catch up, sleep for a while before download! (5 sec will do!) Also
 * it is recommended to call checkin once and use generated android-id for
 * further operations.</b>
 * </p>
 *
 * @author akdeniz
 */
public class GooglePlayAPI {

    private static final String SCHEME = "https://";
    private static final String HOST = "android.clients.google.com";
    private static final String CHECKIN_URL = SCHEME + HOST + "/checkin";
    private static final String URL_LOGIN = SCHEME + HOST + "/auth";
    private static final String C2DM_REGISTER_URL = SCHEME + HOST + "/c2dm/register2";
    private static final String FDFE_URL = SCHEME + HOST + "/fdfe/";
    private static final String LIST_URL = FDFE_URL + "list";
    private static final String BROWSE_URL = FDFE_URL + "browse";
    private static final String DETAILS_URL = FDFE_URL + "details";
    private static final String SEARCH_URL = FDFE_URL + "search";
    private static final String BULKDETAILS_URL = FDFE_URL + "bulkDetails";
    private static final String PURCHASE_URL = FDFE_URL + "purchase";
    private static final String REVIEWS_URL = FDFE_URL + "rev";
    private static final String UPLOADDEVICECONFIG_URL = FDFE_URL + "uploadDeviceConfig";
    private static final String RECOMMENDATIONS_URL = FDFE_URL + "rec";

    private static final String ACCOUNT_TYPE_HOSTED_OR_GOOGLE = "HOSTED_OR_GOOGLE";

    public enum REVIEW_SORT {
        NEWEST(0), HIGHRATING(1), HELPFUL(2);

        public int value;

        REVIEW_SORT(int value) {
            this.value = value;
        }
    }

    public enum RECOMMENDATION_TYPE {
        ALSO_VIEWED(1), ALSO_INSTALLED(2);

        public int value;

        RECOMMENDATION_TYPE(int value) {
            this.value = value;
        }
    }

    private String token;
    private String gsfId;
    private String email;
    private String password;
    private ThrottledHttpClient client;
    private Locale locale;
    private DeviceInfoProvider deviceInfoProvider;
    private Map<String, String> searchNextPage = new HashMap<>();

    public void setToken(String token) {
        this.token = token;
    }

    public void setGsfId(String gsfId) {
        this.gsfId = gsfId;
    }

    public void setDeviceInfoProvider(DeviceInfoProvider deviceInfoProvider) {
        this.deviceInfoProvider = deviceInfoProvider;
    }

    private ThrottledHttpClient getClient() {
        if (this.client == null) {
            HttpParams httpParams = new BasicHttpParams();
            ConnManagerParams.setTimeout(httpParams, 3000);
            ConnManagerParams.setMaxTotalConnections(httpParams, 100);
            ConnManagerParams.setMaxConnectionsPerRoute(httpParams, new ConnPerRouteBean(30));
            this.client = new ThrottledHttpClient(httpParams);
        }
        return this.client;
    }

    public void setLocale(Locale locale) {
        this.locale = locale;
    }

    /**
     * If this constructor is used, Android ID must be generated by calling
     * <code>checkin()</code> or set by using <code>setGsfId</code> before
     * using other abilities.
     */
    public GooglePlayAPI(String email, String password) {
        this.email = email;
        this.password = password;
    }

    /**
     * Performs authentication on "ac2dm" service and match up android id,
     * security token and email by checking them in on this server.
     * <p>
     * This function sets check-inded android ID and that can be taken either by
     * using <code>getToken()</code> or from returned
     * {@link AndroidCheckinResponse} instance.
     */
    public String getGsfId() throws IOException {
        AndroidCheckinRequest request = this.deviceInfoProvider.generateAndroidCheckinRequest();

        // this first checkin is for generating android-id
        AndroidCheckinResponse checkinResponse = checkin(request.toByteArray());
        this.gsfId = BigInteger.valueOf(checkinResponse.getAndroidId()).toString(16);
        String securityToken = BigInteger.valueOf(checkinResponse.getSecurityToken()).toString(16);

        AndroidCheckinRequest.Builder checkInbuilder = AndroidCheckinRequest.newBuilder(request);
        String AC2DMToken = getAC2DMToken();
        AndroidCheckinRequest build = checkInbuilder
            .setId(new BigInteger(this.gsfId, 16).longValue())
            .setSecurityToken(new BigInteger(securityToken, 16).longValue())
            .addAccountCookie("[" + this.email + "]")
            .addAccountCookie(AC2DMToken)
            .build();
        // this is the second checkin to match credentials with android-id
        checkin(build.toByteArray());
        return this.gsfId;
    }

    /**
     * Posts given check-in request content and returns
     * {@link AndroidCheckinResponse}.
     */
    private AndroidCheckinResponse checkin(byte[] request) throws IOException {
        Map<String, String> headers = getDefaultHeaders();
        headers.put("Content-Type", "application/x-protobuffer");
        byte[] content = getClient().post(CHECKIN_URL, new ByteArrayEntity(request), headers);
        return AndroidCheckinResponse.parseFrom(content);
    }

    /**
     * Authenticates on server with given email and password and sets
     * authentication token. This token can be used to login instead of using
     * email and password every time.
     */
    public String getToken() throws IOException {
        Map<String, String> params = getDefaultLoginParams();
        params.put("service", "androidmarket");
        params.put("app", "com.android.vending");
        params.put("androidId", this.getGsfId());
        byte[] responseBytes = getClient().post(URL_LOGIN, params, getDefaultHeaders());
        Map<String, String> response = parseResponse(new String(responseBytes));
        if (response.containsKey("Auth")) {
            return response.get("Auth");
        } else {
            throw new GooglePlayException("Authentication failed! (login)");
        }
    }

    /**
     * Logins AC2DM server and returns authentication string.
     * <p>
     * <p>
     * client_sig is SHA1 digest of encoded certificate on
     * <i>GoogleLoginService(package name : com.google.android.gsf)</i> system APK.
     * But google doesn't seem to care of value of this parameter.
     */
    public String getAC2DMToken() throws IOException {
        Map<String, String> params = getDefaultLoginParams();
        params.put("service", "ac2dm");
        params.put("add_account", "1");
        params.put("app", "com.google.android.gsf");
        byte[] responseBytes = getClient().post(URL_LOGIN, params, getDefaultHeaders());
        Map<String, String> response = parseResponse(new String(responseBytes));
        if (response.containsKey("Auth")) {
            return response.get("Auth");
        } else {
            throw new GooglePlayException("Authentication failed! (loginAC2DM)");
        }
    }

    public Map<String, String> c2dmRegister(String application, String sender) throws IOException {
        Map<String, String> params = new HashMap<>();
        params.put("app", application);
        params.put("sender", sender);
        params.put("device", new BigInteger(this.getGsfId(), 16).toString());
        Map<String, String> headers = getDefaultHeaders();
        headers.put("Authorization", "GoogleLogin auth=" + getAC2DMToken());
        byte[] responseBytes = getClient().post(C2DM_REGISTER_URL, params, headers);
        return parseResponse(new String(responseBytes));
    }

    /**
     * Equivalent of <code>search(query, null, null)</code>
     */
    public SearchResponse search(String query) throws IOException {
        return search(query, null, null);
    }

    /**
     * Fetches a search results for given query. Offset and numberOfResults
     * parameters are optional and <code>null</code> can be passed!
     *
     * Warning! offset and numberOfResults do not seem to work anymore.
     * The api always returns first 30 results. Fetching further results is done through
     * nextPageUrl returned with the search result.
     */
    public SearchResponse search(String query, Integer offset, Integer numberOfResults) throws IOException {
        String url = SEARCH_URL;
        Map<String, String> params = new HashMap<>();
        if (this.searchNextPage.containsKey(query)) {
            url = this.searchNextPage.get(query);
            if (null == url) {
                throw new GooglePlayException("No more results for query " + query);
            }
        } else {
            params = getDefaultGetParams(offset, numberOfResults);
            params.put("q", query);
        }

        ResponseWrapper responseWrapper = ResponseWrapper.parseFrom(getClient().get(url, params, getDefaultHeaders()));
        SearchResponse response = responseWrapper.getPayload().getSearchResponse();
        if (response.getDocCount() > 0
            && response.getDocList().get(0).hasContainerMetadata()
            && response.getDocList().get(0).getContainerMetadata().hasNextPageUrl()
            ) {
            this.searchNextPage.put(query, FDFE_URL + response.getDocList().get(0).getContainerMetadata().getNextPageUrl());
        } else {
            this.searchNextPage.put(query, null);
        }
        return responseWrapper.getPayload().getSearchResponse();
    }

    public boolean hasNextSearchPage(String query) {
        return !this.searchNextPage.containsKey(query) || this.searchNextPage.get(query) != null;
    }

    /**
     * Fetches detailed information about passed package name. If it is needed
     * to fetch information about more than one application, consider to use
     * <code>bulkDetails</code>.
     */
    public DetailsResponse details(String packageName) throws IOException {
        Map<String, String> params = new HashMap<>();
        params.put("doc", packageName);
        ResponseWrapper responseWrapper = ResponseWrapper.parseFrom(getClient().get(DETAILS_URL, params, getDefaultHeaders()));
        return responseWrapper.getPayload().getDetailsResponse();
    }

    /**
     * Equivalent of details but bulky one!
     */
    public BulkDetailsResponse bulkDetails(List<String> packageNames) throws IOException {
        BulkDetailsRequest.Builder bulkDetailsRequestBuilder = BulkDetailsRequest.newBuilder();
        bulkDetailsRequestBuilder.addAllDocid(packageNames);
        byte[] request = bulkDetailsRequestBuilder.build().toByteArray();
        byte[] content = getClient().post(BULKDETAILS_URL, new ByteArrayEntity(request), getDefaultHeaders());
        ResponseWrapper responseWrapper = ResponseWrapper.parseFrom(content);
        return responseWrapper.getPayload().getBulkDetailsResponse();
    }

    /**
     * Fetches available categories
     */
    public BrowseResponse browse() throws IOException {
        return browse(null, null);
    }

    public BrowseResponse browse(String categoryId, String subCategoryId) throws IOException {
        Map<String, String> params = getDefaultGetParams(null, null);
        params.put("cat", categoryId);
        params.put("ctr", subCategoryId);
        ResponseWrapper responseWrapper = ResponseWrapper.parseFrom(getClient().get(BROWSE_URL, params, getDefaultHeaders()));
        return responseWrapper.getPayload().getBrowseResponse();
    }

    /**
     * Equivalent of <code>list(categoryId, null, null, null)</code>. It fetches
     * sub-categories of given category!
     */
    public ListResponse list(String categoryId) throws IOException {
        return list(categoryId, null, null, null);
    }

    /**
     * Fetches applications within supplied category and sub-category. If
     * <code>null</code> is given for sub-category, it fetches sub-categories of
     * passed category.
     * <p>
     * Default values for offset and numberOfResult are "0" and "20"
     * respectively. These values are determined by Google Play Store.
     */
    public ListResponse list(String categoryId, String subCategoryId, Integer offset, Integer numberOfResults) throws IOException {
        Map<String, String> params = getDefaultGetParams(offset, numberOfResults);
        params.put("cat", categoryId);
        params.put("ctr", subCategoryId);
        ResponseWrapper responseWrapper = ResponseWrapper.parseFrom(getClient().get(LIST_URL, params, getDefaultHeaders()));
        return responseWrapper.getPayload().getListResponse();
    }

    /**
     * This function is used for fetching download url and download cookie,
     * rather than actual purchasing.
     */
    public BuyResponse purchase(String packageName, int versionCode, int offerType) throws IOException {
        Map<String, String> params = new HashMap<>();
        params.put("ot", String.valueOf(offerType));
        params.put("doc", packageName);
        params.put("vc", String.valueOf(versionCode));
        ResponseWrapper responseWrapper = ResponseWrapper.parseFrom(getClient().post(PURCHASE_URL, params, getDefaultHeaders()));
        return responseWrapper.getPayload().getBuyResponse();
    }

    /**
     * Fetches the reviews of given package name by sorting passed choice.
     * <p>
     * Default values for offset and numberOfResult are "0" and "20"
     * respectively. These values are determined by Google Play Store.
     */
    public ReviewResponse reviews(String packageName, REVIEW_SORT sort, Integer offset, Integer numberOfResults) throws IOException {
        Map<String, String> params = getDefaultGetParams(offset, numberOfResults);
        params.put("doc", packageName);
        params.put("sort", (sort == null) ? null : String.valueOf(sort.value));
        ResponseWrapper responseWrapper = ResponseWrapper.parseFrom(getClient().get(REVIEWS_URL, params, getDefaultHeaders()));
        return responseWrapper.getPayload().getReviewResponse();
    }

    /**
     * Uploads device configuration to google server so that can be seen from
     * web as a registered device!!
     */
    public UploadDeviceConfigResponse uploadDeviceConfig() throws IOException {
        UploadDeviceConfigRequest request = UploadDeviceConfigRequest.newBuilder()
            .setDeviceConfiguration(this.deviceInfoProvider.getDeviceConfigurationProto())
            .build();
        ResponseWrapper responseWrapper = ResponseWrapper.parseFrom(getClient().post(UPLOADDEVICECONFIG_URL, new ByteArrayEntity(request.toByteArray()), getDefaultHeaders()));
        return responseWrapper.getPayload().getUploadDeviceConfigResponse();
    }

    /**
     * Fetches the recommendations of given package name.
     * <p>
     * Default values for offset and numberOfResult are "0" and "20"
     * respectively. These values are determined by Google Play Store.
     */
    public ListResponse recommendations(String packageName, RECOMMENDATION_TYPE type, Integer offset, Integer numberOfResults) throws IOException {
        Map<String, String> params = getDefaultGetParams(offset, numberOfResults);
        params.put("doc", packageName);
        params.put("rt", (type == null) ? null : String.valueOf(type.value));
        ResponseWrapper responseWrapper = ResponseWrapper.parseFrom(getClient().get(RECOMMENDATIONS_URL, params, getDefaultHeaders()));
        return responseWrapper.getPayload().getListResponse();
    }

    /**
     * login methods use this
     * Most likely not all of these are required, but the Market app sends them, so we will too
     *
     */
    private Map<String, String> getDefaultLoginParams() {
        Map<String, String> params = new HashMap<>();
        params.put("Email", this.email);
        params.put("Passwd", this.password);
        params.put("accountType", ACCOUNT_TYPE_HOSTED_OR_GOOGLE);
        params.put("has_permission", "1");
        params.put("source", "android");
        params.put("device_country", this.locale.getCountry().toLowerCase());
        params.put("lang", this.locale.getLanguage().toLowerCase());
        params.put("sdk_version", String.valueOf(this.deviceInfoProvider.getSdkVersion()));
        params.put("client_sig", "38918a453d07199354f8b19af05ec6562ced5788");
        return params;
    }

    /**
     * Using Accept-Language you can fetch localized informations such as reviews and descriptions.
     * Note that changing this value has no affect on localized application list that
     * server provides. It depends on only your IP location.
     * 
     */
    private Map<String, String> getDefaultHeaders() {
        Map<String, String> headers = new HashMap<>();
        if (this.token != null && !this.token.isEmpty()) {
            headers.put("Authorization", "GoogleLogin auth=" + this.token);
        }
        headers.put("User-Agent", this.deviceInfoProvider.getUserAgentString());
        if (this.gsfId != null && !this.gsfId.isEmpty()) {
            headers.put("X-DFE-Device-Id", this.gsfId);
        }
        headers.put("Accept-Language", this.locale.toString().replace("_", "-"));
        return headers;
    }

    /**
     * Most list requests (apps, categories,..) take these params
     *
     * @param offset
     * @param numberOfResults
     */
    private Map<String, String> getDefaultGetParams(Integer offset, Integer numberOfResults) {
        Map<String, String> params = new HashMap<>();
        params.put("c", "3");
        if (offset != null) {
            params.put("o", String.valueOf(offset));
        }
        if (numberOfResults != null) {
            params.put("n", String.valueOf(numberOfResults));
        }
        return params;
    }

    private static Map<String, String> parseResponse(String response) {
        Map<String, String> keyValueMap = new HashMap<>();
        StringTokenizer st = new StringTokenizer(response, "\n\r");
        while (st.hasMoreTokens()) {
            String[] keyValue = st.nextToken().split("=");
            keyValueMap.put(keyValue[0], keyValue[1]);
        }
        return keyValueMap;
    }
}
